# OutLast Project Cursor Rules

## Project Overview

OutLast is a logistics follow-up automation system that manages multi-channel communication for order tracking and provider outreach. The system reads from various data sources (CSV, Google Sheets, etc.), uses AI to analyze historical memory for order items, determines optimal follow-up timing, and automatically reaches out to providers via their preferred communication channels (SMS, Email, Voice AI). The system escalates to human agents when necessary while maintaining continuous automated follow-up workflows.

## Monorepo Structure

```
outlast/
├── mods/
│   ├── apiserver/          # API server with Prisma
│   ├── datasource/         # Data source readers (CSV, Google Sheets, etc.)
│   ├── ai/                 # AI integration for memory analysis and decision making
│   ├── scheduler/          # Follow-up timing and scheduling logic
│   ├── channels/           # Multi-channel communication (SMS, Email, Voice)
│   │   ├── sms/            # SMS channel implementation
│   │   ├── email/          # Email channel implementation
│   │   └── voice/          # Voice AI channel implementation
│   ├── memory/             # Historical memory storage and retrieval
│   ├── escalation/         # Human escalation logic
│   ├── providers/          # Provider management and preferences
│   ├── orders/             # Order tracking and management
│   ├── common/             # Shared utilities
│   ├── logger/             # Logging utilities
│   ├── types/              # Shared TypeScript types
│   └── dashboard/          # Web UI (Next.js)
├── config/                 # Configuration files
├── etc/                    # Environment configs
└── .scripts/               # Build and utility scripts
```

## TypeScript Conventions

### Function Patterns - Closures with Typed Parameters

CRITICAL: Functions should use the closure pattern with typed parameters for dependency injection and centralized validation/error handling.

```typescript
// ✅ CORRECT: Higher-order function pattern with typed parameters
function createHandler<T, R>(config: HandlerConfig) {
  return async function handler(request: T): Promise<R> {
    // Validation and error handling centralized here
    validateRequest(request);
    try {
      return await processRequest(request);
    } catch (error) {
      return handleError(error);
    }
  };
}

// ✅ CORRECT: Factory function returning configured handler
export const createFollowUpHandler = (config: FollowUpConfig) => {
  return async (order: Order): Promise<FollowUpResult> => {
    // Handler logic with access to config via closure
    const shouldFollowUp = await checkFollowUpTiming(order, config);
    // ... implementation
  };
};

// ✅ CORRECT: Service factory with dependency injection
function createOrderService(dependencies: OrderServiceDependencies) {
  const { prisma, logger, aiService, channelService } = dependencies;
  
  return {
    async processOrder(orderData: CreateOrderInput): Promise<Order> {
      logger.info('Processing order', { orderId: orderData.id });
      const order = await prisma.order.create({ data: orderData });
      await aiService.analyzeOrderHistory(order.id);
      return order;
    },
    
    async getOrder(id: string): Promise<Order | null> {
      return prisma.order.findUnique({ where: { id } });
    }
  };
}

// ❌ AVOID: Direct function without closure for configuration
function handleOrder(order: Order) {
  // No access to configuration or dependencies
}
```

### Wrapper Functions for Validation and Error Handling

```typescript
// ✅ CORRECT: Higher-order function wrapping for centralized concerns
function withErrorHandling<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  errorHandler: ErrorHandler
): T {
  return (async (...args: Parameters<T>) => {
    try {
      return await fn(...args);
    } catch (error) {
      return errorHandler.handle(error);
    }
  }) as T;
}

function withValidation<T, R>(
  schema: ValidationSchema<T>,
  handler: (validated: T) => Promise<R>
) {
  return async (input: unknown): Promise<R> => {
    const validated = schema.parse(input);
    return handler(validated);
  };
}

// Usage
const createOrder = withErrorHandling(
  withValidation(CreateOrderSchema, async (data) => {
    return orderService.create(data);
  }),
  errorHandler
);
```

### Type Definitions

```typescript
// ✅ CORRECT: Use explicit interfaces for public APIs
export interface CreateOrderRequest {
  orderId: string;
  providerId: string;
  items: OrderItem[];
  expectedDeliveryDate: Date;
  priority?: OrderPriority;
}

// ✅ CORRECT: Use type for unions and simple types
export type CommunicationChannel = 'SMS' | 'EMAIL' | 'VOICE';
export type OrderStatus = 'PENDING' | 'IN_TRANSIT' | 'DELIVERED' | 'DELAYED';

// ✅ CORRECT: Typed configuration objects
interface FollowUpConfig {
  readonly minDaysBetweenFollowUps: number;
  readonly maxFollowUpAttempts: number;
  readonly escalationThreshold: number;
}

// ✅ CORRECT: Generic types for reusable patterns
interface PaginatedResponse<T> {
  items: T[];
  nextPageToken?: string;
  totalCount: number;
}
```

## Naming Conventions

### Files and Directories

- **Source files**: `kebab-case.ts` (e.g., `order-processor.ts`, `follow-up-manager.ts`)
- **Test files**: `*.test.ts` (e.g., `order-processor.test.ts`)
- **Integration tests**: `*.integration.ts` (e.g., `order.integration.ts`)
- **Index files**: `index.ts` for module exports
- **Types files**: `types.ts` for module-specific types

### Code Identifiers

```typescript
// Classes: PascalCase
class OrderProcessor {}
class FollowUpManager {}
class ChannelHandler {}

// Interfaces: PascalCase (no 'I' prefix)
interface OrderRequest {}
interface FollowUpConfig {}

// Types: PascalCase
type CommunicationChannel = 'SMS' | 'EMAIL' | 'VOICE';

// Functions: camelCase
function createOrder() {}
function processFollowUp() {}

// Variables: camelCase
const orderProcessor = new OrderProcessor();
const orderId = 'ORD-12345';

// Constants: UPPER_SNAKE_CASE for true constants
const DEFAULT_FOLLOW_UP_INTERVAL = 7; // days
const MAX_FOLLOW_UP_ATTEMPTS = 5;

// Enums: PascalCase with UPPER_SNAKE_CASE values
enum OrderStatus {
  PENDING = 'PENDING',
  IN_TRANSIT = 'IN_TRANSIT',
  DELIVERED = 'DELIVERED',
  DELAYED = 'DELAYED'
}
```

### Module Exports

```typescript
// ✅ CORRECT: Named exports for utilities and types
export { OrderProcessor } from './order-processor';
export { createFollowUp } from './follow-up';
export type { OrderRequest, FollowUpResult } from './types';

// ✅ CORRECT: Default export for main module class
export default OrderProcessor;

// ✅ CORRECT: Barrel exports in index.ts
export * from './order-processor';
export * from './types';
export * from './utils';
```

## Data Source Patterns

### Data Source Reader Interface

```typescript
// ✅ CORRECT: Generic data source reader interface
interface DataSourceReader<T> {
  read(): Promise<T[]>;
  validate(data: T[]): boolean;
}

// ✅ CORRECT: CSV reader implementation
function createCsvReader(config: CsvReaderConfig): DataSourceReader<OrderData> {
  return {
    async read(): Promise<OrderData[]> {
      const content = await readFile(config.filePath, 'utf-8');
      return parseCsv(content);
    },
    validate(data: OrderData[]): boolean {
      return data.every(item => item.orderId && item.providerId);
    }
  };
}

// ✅ CORRECT: Google Sheets reader implementation
function createGoogleSheetsReader(
  config: GoogleSheetsConfig
): DataSourceReader<OrderData> {
  return {
    async read(): Promise<OrderData[]> {
      const sheets = await initializeSheets(config.credentials);
      const rows = await sheets.spreadsheets.values.get({
        spreadsheetId: config.spreadsheetId,
        range: config.range
      });
      return parseSheetRows(rows.data.values || []);
    },
    validate(data: OrderData[]): boolean {
      return data.length > 0 && data.every(item => item.orderId);
    }
  };
}
```

## AI Integration Patterns

### AI Service for Memory Analysis

```typescript
// ✅ CORRECT: AI service with memory context
interface AIService {
  analyzeOrderHistory(orderId: string): Promise<OrderAnalysis>;
  shouldFollowUp(order: Order, history: OrderHistory[]): Promise<boolean>;
  generateFollowUpMessage(order: Order, context: FollowUpContext): Promise<string>;
}

function createAIService(config: AIServiceConfig): AIService {
  const { apiKey, model, memoryStore } = config;
  
  return {
    async analyzeOrderHistory(orderId: string): Promise<OrderAnalysis> {
      const history = await memoryStore.getOrderHistory(orderId);
      const prompt = buildAnalysisPrompt(history);
      const response = await callAI(prompt, { apiKey, model });
      return parseAnalysis(response);
    },
    
    async shouldFollowUp(order: Order, history: OrderHistory[]): Promise<boolean> {
      const lastFollowUp = history[history.length - 1];
      const daysSinceLastFollowUp = calculateDaysSince(lastFollowUp?.timestamp);
      
      if (daysSinceLastFollowUp < config.minDaysBetweenFollowUps) {
        return false;
      }
      
      const prompt = buildFollowUpDecisionPrompt(order, history);
      const response = await callAI(prompt, { apiKey, model });
      return response.shouldFollowUp === true;
    },
    
    async generateFollowUpMessage(
      order: Order,
      context: FollowUpContext
    ): Promise<string> {
      const history = await memoryStore.getOrderHistory(order.id);
      const prompt = buildMessagePrompt(order, history, context);
      const response = await callAI(prompt, { apiKey, model });
      return response.message;
    }
  };
}
```

## Multi-Channel Communication Patterns

### Channel Service Interface

```typescript
// ✅ CORRECT: Unified channel interface
interface ChannelService {
  send(message: ChannelMessage): Promise<ChannelResponse>;
  getChannelType(): CommunicationChannel;
}

interface ChannelMessage {
  to: string;
  content: string;
  orderId: string;
  metadata?: Record<string, unknown>;
}

// ✅ CORRECT: SMS channel implementation
function createSmsChannel(config: SmsChannelConfig): ChannelService {
  return {
    getChannelType(): CommunicationChannel {
      return 'SMS';
    },
    async send(message: ChannelMessage): Promise<ChannelResponse> {
      const result = await smsProvider.send({
        to: message.to,
        body: message.content,
        metadata: message.metadata
      });
      return {
        success: result.success,
        messageId: result.id,
        channel: 'SMS'
      };
    }
  };
}

// ✅ CORRECT: Email channel implementation
function createEmailChannel(config: EmailChannelConfig): ChannelService {
  return {
    getChannelType(): CommunicationChannel {
      return 'EMAIL';
    },
    async send(message: ChannelMessage): Promise<ChannelResponse> {
      const result = await emailProvider.send({
        to: message.to,
        subject: `Order Update: ${message.orderId}`,
        body: message.content,
        metadata: message.metadata
      });
      return {
        success: result.success,
        messageId: result.id,
        channel: 'EMAIL'
      };
    }
  };
}

// ✅ CORRECT: Channel router based on provider preferences
function createChannelRouter(
  channels: Map<CommunicationChannel, ChannelService>,
  providerService: ProviderService
): ChannelRouter {
  return {
    async sendToProvider(
      providerId: string,
      message: string,
      orderId: string
    ): Promise<ChannelResponse> {
      const provider = await providerService.getProvider(providerId);
      const preferredChannel = provider.preferredChannel || 'EMAIL';
      const channel = channels.get(preferredChannel);
      
      if (!channel) {
        throw new Error(`Channel ${preferredChannel} not available`);
      }
      
      return channel.send({
        to: provider.contactInfo[preferredChannel],
        content: message,
        orderId
      });
    }
  };
}
```

## Follow-Up Scheduling Patterns

```typescript
// ✅ CORRECT: Follow-up scheduler with AI decision making
function createFollowUpScheduler(
  dependencies: FollowUpSchedulerDependencies
): FollowUpScheduler {
  const { orderService, aiService, channelRouter, memoryStore, logger } = dependencies;
  
  return {
    async checkAndScheduleFollowUps(): Promise<void> {
      const pendingOrders = await orderService.getPendingOrders();
      
      for (const order of pendingOrders) {
        const history = await memoryStore.getOrderHistory(order.id);
        const shouldFollowUp = await aiService.shouldFollowUp(order, history);
        
        if (shouldFollowUp) {
          logger.info('Scheduling follow-up', { orderId: order.id });
          await this.executeFollowUp(order, history);
        }
      }
    },
    
    async executeFollowUp(order: Order, history: OrderHistory[]): Promise<void> {
      const context = buildFollowUpContext(order, history);
      const message = await aiService.generateFollowUpMessage(order, context);
      
      try {
        const response = await channelRouter.sendToProvider(
          order.providerId,
          message,
          order.id
        );
        
        await memoryStore.recordFollowUp({
          orderId: order.id,
          channel: response.channel,
          message,
          timestamp: new Date(),
          success: response.success
        });
        
        if (history.length >= dependencies.config.escalationThreshold) {
          await this.escalateToHuman(order, history);
        }
      } catch (error) {
        logger.error('Follow-up failed', { orderId: order.id, error });
        throw error;
      }
    },
    
    async escalateToHuman(order: Order, history: OrderHistory[]): Promise<void> {
      logger.warn('Escalating to human', { orderId: order.id, attempts: history.length });
      await dependencies.escalationService.createEscalation({
        orderId: order.id,
        reason: 'MAX_FOLLOW_UP_ATTEMPTS_REACHED',
        history
      });
    }
  };
}
```

## Database (Prisma) Conventions

### Schema Naming

```prisma
// Model names: PascalCase, singular
model Order {
  id                  String   @id @default(uuid())
  orderId             String   @unique
  providerId          String
  status              OrderStatus
  expectedDeliveryDate DateTime
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")
  
  // Relations
  provider            Provider @relation(fields: [providerId], references: [id])
  followUps           FollowUp[]
  items               OrderItem[]
  
  @@map("orders")  // Table name: lowercase, plural
}

model FollowUp {
  id        String   @id @default(uuid())
  orderId   String
  channel   CommunicationChannel
  message   String
  success   Boolean
  timestamp DateTime @default(now()) @map("timestamp")
  
  order     Order    @relation(fields: [orderId], references: [id])
  
  @@map("follow_ups")
}

model Provider {
  id              String   @id @default(uuid())
  name            String
  preferredChannel CommunicationChannel
  contactInfo     Json     // { SMS: "+1234567890", EMAIL: "provider@example.com" }
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  orders          Order[]
  
  @@map("providers")
}

// Enums: PascalCase
enum OrderStatus {
  PENDING
  IN_TRANSIT
  DELIVERED
  DELAYED
}

enum CommunicationChannel {
  SMS
  EMAIL
  VOICE
}

// Use @map for snake_case database columns
// Use @@map for snake_case table names
```

### Query Patterns

```typescript
// ✅ CORRECT: Use Prisma client with typed queries
const order = await prisma.order.findUnique({
  where: { orderId },
  include: { 
    provider: true,
    followUps: {
      orderBy: { timestamp: 'desc' },
      take: 10
    }
  }
});

// ✅ CORRECT: Transactions for related operations
const result = await prisma.$transaction(async (tx) => {
  const order = await tx.order.create({ data: orderData });
  await tx.followUp.create({ 
    data: { 
      orderId: order.id, 
      channel: 'EMAIL',
      message: followUpMessage,
      success: true
    } 
  });
  return order;
});
```

## Testing Conventions

### Test Framework: Mocha + Chai

```typescript
import { expect } from 'chai';
import sinon from 'sinon';

describe('OrderService', () => {
  let sandbox: sinon.SinonSandbox;
  let service: OrderService;
  let mockPrisma: MockPrismaClient;
  let mockAIService: MockAIService;

  beforeEach(() => {
    sandbox = sinon.createSandbox();
    mockPrisma = createMockPrisma();
    mockAIService = createMockAIService();
    service = new OrderService(mockPrisma, mockAIService);
  });

  afterEach(() => {
    sandbox.restore();
  });

  describe('#processOrder', () => {
    it('should process order with valid input', async () => {
      // Arrange
      const input = {
        orderId: 'ORD-123',
        providerId: 'PROV-456',
        items: [{ sku: 'ITEM-001', quantity: 10 }],
        expectedDeliveryDate: new Date()
      };
      
      mockPrisma.order.create.resolves({
        id: 'uuid-123',
        ...input,
        status: 'PENDING',
        createdAt: new Date(),
        updatedAt: new Date()
      });
      mockAIService.analyzeOrderHistory.resolves({
        riskLevel: 'LOW',
        estimatedDelay: null
      });

      // Act
      const result = await service.processOrder(input);

      // Assert
      expect(result).to.have.property('id');
      expect(result.orderId).to.equal(input.orderId);
      expect(mockPrisma.order.create.calledOnce).to.be.true;
      expect(mockAIService.analyzeOrderHistory.calledOnce).to.be.true;
    });

    it('should throw ValidationError for invalid input', async () => {
      // Arrange
      const input = { orderId: '', providerId: '' };

      // Act & Assert
      await expect(service.processOrder(input as any))
        .to.be.rejectedWith(ValidationError);
    });
  });
});
```

### Test File Organization

```
mods/orders/
├── src/
│   ├── order-processor/
│   │   ├── order-processor.ts
│   │   ├── order-processor.test.ts      # Unit tests
│   │   └── types.ts
│   └── index.ts
└── order.integration.ts                 # Integration tests
```

### Test Patterns

```typescript
// ✅ CORRECT: Use descriptive test names
it('should return false when not enough time has passed since last follow-up', async () => {});
it('should validate order ID format before processing', async () => {});

// ✅ CORRECT: Arrange-Act-Assert pattern
it('should send follow-up via provider preferred channel', async () => {
  // Arrange
  const order = createTestOrder();
  const provider = createTestProvider({ preferredChannel: 'SMS' });
  
  // Act
  const response = await followUpService.sendFollowUp(order, provider);
  
  // Assert
  expect(response.channel).to.equal('SMS');
  expect(response.success).to.be.true;
});

// ✅ CORRECT: Use stubs for external dependencies
it('should handle AI service failures gracefully', async () => {
  sandbox.stub(aiService, 'shouldFollowUp').rejects(new Error('AI service unavailable'));
  
  await expect(followUpScheduler.checkAndScheduleFollowUps())
    .to.be.rejectedWith('AI service unavailable');
});
```

## Error Handling

### Custom Error Classes

```typescript
// ✅ CORRECT: Domain-specific error classes
export class OutLastError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'OutLastError';
  }
}

export class ValidationError extends OutLastError {
  constructor(message: string, details?: Record<string, unknown>) {
    super(message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends OutLastError {
  constructor(resource: string, identifier: string) {
    super(`${resource} not found: ${identifier}`, 'NOT_FOUND', { resource, identifier });
    this.name = 'NotFoundError';
  }
}

export class ChannelError extends OutLastError {
  constructor(channel: CommunicationChannel, message: string, details?: Record<string, unknown>) {
    super(`Channel ${channel} error: ${message}`, 'CHANNEL_ERROR', { channel, ...details });
    this.name = 'ChannelError';
  }
}
```

### Error Handling Pattern

```typescript
// ✅ CORRECT: Centralized error handler
function handleError(error: unknown): never {
  if (error instanceof ValidationError) {
    logger.warn('Validation failed', { error: error.details });
    throw error;
  }
  
  if (error instanceof NotFoundError) {
    logger.info('Resource not found', { error: error.details });
    throw error;
  }
  
  if (error instanceof ChannelError) {
    logger.error('Channel communication failed', { error: error.details });
    throw error;
  }
  
  logger.error('Unexpected error', { error });
  throw new OutLastError('Internal server error', 'INTERNAL_ERROR');
}
```

## Logging Conventions

```typescript
import { getLogger } from '@outlast/logger';

const logger = getLogger({ service: 'orders', filePath: __filename });

// ✅ CORRECT: Structured logging with context
logger.verbose('Processing order', { orderId, providerId, method: 'processOrder' });
logger.info('Order created', { orderId: order.id, providerId: order.providerId });
logger.info('Follow-up sent', { orderId, channel: 'SMS', providerId });
logger.warn('Escalating to human', { orderId, followUpAttempts: history.length });
logger.error('Failed to send follow-up', { error: error.message, orderId, channel });
```

## Configuration

### Environment Variables

```typescript
// ✅ CORRECT: Type-safe configuration
interface Config {
  NODE_ENV: 'development' | 'production' | 'test';
  LOGS_LEVEL: 'verbose' | 'info' | 'warn' | 'error';
  DATABASE_URL: string;
  AI_API_KEY: string;
  AI_MODEL: string;
  SMS_PROVIDER_API_KEY?: string;
  EMAIL_SMTP_HOST?: string;
  EMAIL_SMTP_PORT?: number;
  GOOGLE_SHEETS_CREDENTIALS?: string;
  MIN_DAYS_BETWEEN_FOLLOW_UPS: number;
  MAX_FOLLOW_UP_ATTEMPTS: number;
  ESCALATION_THRESHOLD: number;
  PORT: number;
}

function loadConfig(): Config {
  return {
    NODE_ENV: process.env.NODE_ENV as Config['NODE_ENV'] || 'development',
    LOGS_LEVEL: process.env.LOGS_LEVEL as Config['LOGS_LEVEL'] || 'info',
    DATABASE_URL: requireEnv('DATABASE_URL'),
    AI_API_KEY: requireEnv('AI_API_KEY'),
    AI_MODEL: process.env.AI_MODEL || 'gpt-4',
    SMS_PROVIDER_API_KEY: process.env.SMS_PROVIDER_API_KEY,
    EMAIL_SMTP_HOST: process.env.EMAIL_SMTP_HOST,
    EMAIL_SMTP_PORT: parseInt(process.env.EMAIL_SMTP_PORT || '587', 10),
    GOOGLE_SHEETS_CREDENTIALS: process.env.GOOGLE_SHEETS_CREDENTIALS,
    MIN_DAYS_BETWEEN_FOLLOW_UPS: parseInt(process.env.MIN_DAYS_BETWEEN_FOLLOW_UPS || '7', 10),
    MAX_FOLLOW_UP_ATTEMPTS: parseInt(process.env.MAX_FOLLOW_UP_ATTEMPTS || '5', 10),
    ESCALATION_THRESHOLD: parseInt(process.env.ESCALATION_THRESHOLD || '3', 10),
    PORT: parseInt(process.env.PORT || '3000', 10)
  };
}

function requireEnv(name: string): string {
  const value = process.env[name];
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}
```

## Import Order

```typescript
// 1. Node.js built-in modules
import { join } from 'path';
import { readFile } from 'fs/promises';

// 2. External dependencies
import express from 'express';
import { PrismaClient } from '@prisma/client';

// 3. Internal @outlast packages
import { getLogger } from '@outlast/logger';
import { ValidationError } from '@outlast/common';

// 4. Relative imports - types first
import type { OrderConfig, FollowUpConfig } from './types';

// 5. Relative imports - implementations
import { createHandler } from './handler';
import { validateInput } from './validation';
```

## Code Formatting (Prettier)

```json
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "none",
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "always"
}
```

## ESLint Configuration

Key rules to follow:
- Use `@typescript-eslint` rules for TypeScript-specific linting
- Prefer `const` over `let` when variable is not reassigned
- No unused variables (except those prefixed with `_`)
- Explicit return types on exported functions
- No `any` type (use `unknown` and type guards instead)

## Git Commit Messages

```
feat(orders): add order processing with AI analysis
feat(channels): implement SMS channel integration
fix(scheduler): resolve follow-up timing calculation issue
docs(ai): update AI service documentation
test(orders): add unit tests for order validation
refactor(channels): extract channel router logic
chore(deps): update dependencies
```

## Key Principles

1. **AI-First Decision Making**: Use AI to analyze historical memory and determine follow-up actions
2. **Multi-Channel Support**: Support multiple communication channels with provider preferences
3. **Type Safety**: Use TypeScript strictly, avoid `any`
4. **Closure Pattern**: Use higher-order functions for configuration and dependency injection
5. **Centralized Error Handling**: Wrap handlers with error handling HOFs
6. **Testability**: Design for dependency injection and mockability
7. **Consistent Naming**: Follow the naming conventions strictly
8. **Documentation**: Use JSDoc for public APIs
9. **Human Escalation**: Always provide a path to human intervention when automation fails
10. **Data Source Flexibility**: Support multiple data source formats (CSV, Google Sheets, etc.)
